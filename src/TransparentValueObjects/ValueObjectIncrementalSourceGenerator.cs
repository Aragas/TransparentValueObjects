using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TransparentValueObjects;

[Generator]
public class ValueObjectIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TransparentValueObjects.Generated";
    private const string AttributeClassName = "ValueObjectAttribute";

    private const string AttributeSourceCode =
$$"""
// <auto-generated/>

namespace {{GeneratedNamespace}}
{
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Auto-generated")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
    public class {{AttributeClassName}}<T> : global::System.Attribute { }
}
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeClassName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                Predicate,
                Transform
            )
            .Where(static target => target is not null);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, tuple) => Generate(ctx, tuple.Left, tuple.Right)
        );
    }

    private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is StructDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static Target? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var syntaxNode = (StructDeclarationSyntax) context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(syntaxNode, cancellationToken);

        if (symbol is null) return null;

        var attributes = symbol.GetAttributes();
        if (attributes.Length == 0) return null;

        var attributeData = attributes.FirstOrDefault(static a => a?.AttributeClass?.Name == $"{AttributeClassName}");
        if (attributeData is null) return null;

        return new Target(syntaxNode, attributeData);
    }

    private static void Generate(SourceProductionContext context, Compilation compilation, ImmutableArray<Target?> targets)
    {
        foreach (var target in targets)
        {
            if (target is null) continue;
            var syntax = target.Syntax;
            var attributeData = target.AttributeData;

            var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(syntax);

            if (symbol is not INamedTypeSymbol namedTypeSymbol) continue;

            var namespaceName = namedTypeSymbol.ContainingNamespace.ToDisplayString();
            var identifier = namedTypeSymbol.Name;

            var underlyingType = attributeData.AttributeClass?.TypeArguments.FirstOrDefault();
            if (underlyingType is not INamedTypeSymbol underlyingNamedType) continue;

            var typeIdentifier = $"global::{underlyingNamedType.ContainingNamespace.ToDisplayString()}.{underlyingNamedType.Name}";
            var typeNullableAnnotation = underlyingNamedType.IsReferenceType ? "?" : "";

            var sb = new StringBuilder();

            // header, namespace and type definition
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = \"Auto-generated.\")]");
            sb.AppendLine($"readonly partial struct {identifier} :");

            // interfaces
            sb.AppendLine($"\tglobal::System.IEquatable<{identifier}>,");
            sb.AppendLine($"\tglobal::System.IEquatable<{typeIdentifier}>");

            sb.AppendLine("{");

            // backing field
            sb.AppendLine($"\tpublic readonly {typeIdentifier} Value;");
            sb.AppendLine();

            // public default constructor
            sb.AppendLine($"\t[global::System.Obsolete($\"Use {identifier}.{{nameof(From)}} instead.\", error: true)]");
            sb.AppendLine($"\tpublic {identifier}()");
            sb.AppendLine("\t{");
            sb.AppendLine($"\t\tthrow new global::System.InvalidOperationException($\"Use {identifier}.{{nameof(From)}} instead.\");");
            sb.AppendLine("\t}");
            sb.AppendLine();

            // private constructor with value
            sb.AppendLine($"\tprivate {identifier}({typeIdentifier} value)");
            sb.AppendLine("\t{");
            sb.AppendLine("\t\tValue = value;");
            sb.AppendLine("\t}");
            sb.AppendLine();

            // public From method
            sb.AppendLine($"\tpublic static {identifier} From({typeIdentifier} value) => new(value);");
            sb.AppendLine();

            // hash code
            sb.AppendLine("\tpublic override int GetHashCode() => Value.GetHashCode();");
            sb.AppendLine();

            // ToString
            sb.AppendLine("\tpublic override string ToString() => Value.ToString();");
            sb.AppendLine();

            // IEquality<Self>
            sb.AppendLine($"\tpublic bool Equals({identifier} other) => Value.Equals(other.Value);");

            // IEquality<Value>
            sb.AppendLine($"\tpublic bool Equals({typeIdentifier}{typeNullableAnnotation} other) => Value.Equals(other);");

            // with equality comparer
            sb.AppendLine($"\tpublic bool Equals({identifier} other, global::System.Collections.Generic.IEqualityComparer<{typeIdentifier}> comparer) => comparer.Equals(Value, other.Value);");

            // object.Equals
            sb.AppendLine("\tpublic override bool Equals(object? obj)");
            sb.AppendLine("\t{");
            sb.AppendLine("\t\tif (obj is null) return false;");
            sb.AppendLine($"\t\tif (obj is {identifier} value) return Equals(value);");
            sb.AppendLine($"\t\tif (obj is {typeIdentifier} innerValue) return Equals(innerValue);");
            sb.AppendLine("\t\treturn false;");
            sb.AppendLine("\t}");
            sb.AppendLine();

            // equality operators
            sb.AppendLine($"\tpublic static bool operator ==({identifier} left, {identifier} right) => left.Equals(right);");
            sb.AppendLine($"\tpublic static bool operator !=({identifier} left, {identifier} right) => !left.Equals(right);");
            sb.AppendLine();

            sb.AppendLine($"\tpublic static bool operator ==({identifier} left, {typeIdentifier} right) => left.Equals(right);");
            sb.AppendLine($"\tpublic static bool operator !=({identifier} left, {typeIdentifier} right) => !left.Equals(right);");
            sb.AppendLine();

            sb.AppendLine($"\tpublic static bool operator ==({typeIdentifier} left, {identifier} right) => right.Equals(left);");
            sb.AppendLine($"\tpublic static bool operator !=({typeIdentifier} left, {identifier} right) => !right.Equals(left);");
            sb.AppendLine();

            // explicit cast operators
            sb.AppendLine($"\tpublic static explicit operator {identifier}({typeIdentifier} value) => From(value);");
            sb.AppendLine($"\tpublic static explicit operator {typeIdentifier}({identifier} value) => value.Value;");
            sb.AppendLine();

            sb.AppendLine("}");

            context.AddSource($"{identifier}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private class Target
    {
        public readonly StructDeclarationSyntax Syntax;
        public readonly AttributeData AttributeData;

        public Target(StructDeclarationSyntax syntax, AttributeData attributeData)
        {
            Syntax = syntax;
            AttributeData = attributeData;
        }
    }
}
