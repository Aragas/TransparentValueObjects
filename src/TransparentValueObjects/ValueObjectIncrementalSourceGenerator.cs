using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TransparentValueObjects;

[Generator]
public class ValueObjectIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TransparentValueObjects.Generated";
    private const string AttributeClassName = "ValueObjectAttribute";

    private const string AttributeSourceCode =
$$"""
// <auto-generated/>

namespace {{GeneratedNamespace}}
{
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Auto-generated")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
    public class {{AttributeClassName}}<T> : global::System.Attribute { }
}
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeClassName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                Predicate,
                Transform
            )
            .Where(static target => target is not null);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, tuple) => Generate(ctx, tuple.Left, tuple.Right)
        );
    }

    private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is StructDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static Target? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var syntaxNode = (StructDeclarationSyntax) context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(syntaxNode, cancellationToken);

        if (symbol is null) return null;

        var attributes = symbol.GetAttributes();
        if (attributes.Length == 0) return null;

        var attributeData = attributes.FirstOrDefault(static a => a?.AttributeClass?.Name == $"{AttributeClassName}");
        if (attributeData is null) return null;

        return new Target(syntaxNode, attributeData);
    }

    private static void Generate(SourceProductionContext context, Compilation compilation, ImmutableArray<Target?> targets)
    {
        foreach (var target in targets)
        {
            if (target is null) continue;
            var syntax = target.Syntax;
            var attributeData = target.AttributeData;

            var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(syntax);

            if (symbol is not INamedTypeSymbol namedTypeSymbol) continue;

            var namespaceName = namedTypeSymbol.ContainingNamespace.ToDisplayString();
            var identifier = namedTypeSymbol.Name;

            var underlyingType = attributeData.AttributeClass?.TypeArguments.FirstOrDefault();
            if (underlyingType is not INamedTypeSymbol underlyingNamedType) continue;

            var typeIdentifier = $"global::{underlyingNamedType.ContainingNamespace.ToDisplayString()}.{underlyingNamedType.Name}";

            var sb = new StringBuilder();

            // header, namespace and type definition
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = \"Auto-generated.\")]");
            sb.AppendLine($"readonly partial struct {identifier}");
            sb.AppendLine("{");

            // backing field
            sb.AppendLine($"\tpublic readonly {typeIdentifier} Value;");

            // public default constructor
            sb.AppendLine($"\t[global::System.Obsolete($\"Use {identifier}.{{nameof(From)}} instead.\", error: true)]");
            sb.AppendLine($"\tpublic {identifier}()");
            sb.AppendLine("\t{");
            sb.AppendLine($"\t\tthrow new global::System.InvalidOperationException($\"Use {identifier}.{{nameof(From)}} instead.\");");
            sb.AppendLine("\t}");

            // private constructor with value
            sb.AppendLine($"\tprivate {identifier}({typeIdentifier} value)");
            sb.AppendLine("\t{");
            sb.AppendLine("\t\tValue = value;");
            sb.AppendLine("\t}");

            // public From method
            sb.AppendLine($"\tpublic static {identifier} From({typeIdentifier} value) => new(value);");

            sb.AppendLine("}");

            context.AddSource($"{identifier}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private class Target
    {
        public readonly StructDeclarationSyntax Syntax;
        public readonly AttributeData AttributeData;

        public Target(StructDeclarationSyntax syntax, AttributeData attributeData)
        {
            Syntax = syntax;
            AttributeData = attributeData;
        }
    }
}
