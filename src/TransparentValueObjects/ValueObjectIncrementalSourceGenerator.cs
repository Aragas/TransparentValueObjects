using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TransparentValueObjects;

[Generator]
public class ValueObjectIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TransparentValueObjects.Generated";
    private const string AttributeClassName = "ValueObjectAttribute";

    private const string AugmentedNamespace = "TransparentValueObjects.Augments";
    private const string ValueObjectInterfaceName = "IValueObject";
    private const string HasDefaultValueInterfaceName = "IHasDefaultValue";
    private const string HasDefaultEqualityComparerInterfaceName = "IHasDefaultEqualityComparer";

    private const string AttributeSourceCode =
$$"""
// <auto-generated/>

namespace {{GeneratedNamespace}}
{
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Auto-generated")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
    public class {{AttributeClassName}}<T> : global::System.Attribute { }
}
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeClassName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                Predicate,
                Transform
            )
            .Where(t => !t.Equals(default));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, tuple) => Generate(ctx, tuple.Left, tuple.Right)
        );
    }

    private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is StructDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static Target Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var syntaxNode = (StructDeclarationSyntax) context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(syntaxNode, cancellationToken);

        if (symbol is null) return default;

        var attributes = symbol.GetAttributes();
        if (attributes.Length == 0) return default;

        var attributeData = attributes.FirstOrDefault(static a => a?.AttributeClass?.Name == $"{AttributeClassName}");
        if (attributeData is null) return default;

        return new Target(syntaxNode, attributeData);
    }

    private static void Generate(SourceProductionContext context, Compilation compilation, ImmutableArray<Target> targets)
    {
        foreach (var target in targets)
        {
            var syntax = target.Syntax;
            var attributeData = target.AttributeData;

            var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(syntax);

            if (symbol is not INamedTypeSymbol namedTypeSymbol) continue;

            var namespaceName = namedTypeSymbol.ContainingNamespace.ToDisplayString();
            var valueObjectTypeName = namedTypeSymbol.Name;

            var underlyingType = attributeData.AttributeClass?.TypeArguments.FirstOrDefault();
            if (underlyingType is not INamedTypeSymbol underlyingNamedType) continue;

            var innerValueTypeName = $"global::{underlyingNamedType.ContainingNamespace.ToDisplayString()}.{underlyingNamedType.Name}";
            var innerValueTypeNullableAnnotation = underlyingNamedType.IsReferenceType ? "?" : "";

            var existingInterfaces = namedTypeSymbol.Interfaces;

            var cw = new CodeWriter();

            // header, namespace and type definition
            cw.AppendLine("// <auto-generated/>");
            cw.AppendLine("#nullable enable");
            cw.AppendLine($"namespace {namespaceName};");
            cw.AppendLine();

            cw.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = \"Auto-generated.\")]");
            cw.AppendLine($"readonly partial struct {valueObjectTypeName} :");

            // interfaces
            cw.AppendLine($"\tglobal::{AugmentedNamespace}.{ValueObjectInterfaceName}<{innerValueTypeName}>,");
            cw.AppendLine($"\tglobal::System.IEquatable<{valueObjectTypeName}>,");
            cw.AppendLine($"\tglobal::System.IEquatable<{innerValueTypeName}>");

            using (cw.AddBlock())
            {
                // backing field
                cw.AppendLine($"public readonly {innerValueTypeName} Value;");
                cw.AppendLine();

                // public default constructor
                var hasDefaultValue = HasAugment(existingInterfaces, HasDefaultValueInterfaceName);
                AddPublicConstructor(cw, valueObjectTypeName, hasDefaultValue);

                // private constructor with value
                AddPrivateConstructor(cw, valueObjectTypeName, innerValueTypeName);

                // public From method
                cw.AppendLine($"public static {valueObjectTypeName} From({innerValueTypeName} value) => new(value);");
                cw.AppendLine();

                // ToString and GetHashCode
                OverrideBaseMethods(cw);

                // Equals methods from interfaces and base object
                var hasDefaultEqualityComparer = HasAugment(existingInterfaces, HasDefaultEqualityComparerInterfaceName);
                ImplementEqualsMethods(cw, valueObjectTypeName, innerValueTypeName, innerValueTypeNullableAnnotation, hasDefaultEqualityComparer);

                // equality operators
                AddEqualityOperators(cw, valueObjectTypeName, innerValueTypeName);

                // explicit cast operators
                AddExplicitCastOperators(cw, valueObjectTypeName, innerValueTypeName);

                if (innerValueTypeName == "global::System.Guid")
                    AddGuidSpecificCode(cw, valueObjectTypeName, innerValueTypeName);
            }

            context.AddSource($"{valueObjectTypeName}.g.cs", SourceText.From(cw.ToString(), Encoding.UTF8));
        }
    }

    private static bool HasAugment(ImmutableArray<INamedTypeSymbol> existingInterfaces, string augmentName)
    {
        return existingInterfaces.Any(x => x.Name == augmentName && x.ContainingNamespace.ToDisplayString() == AugmentedNamespace);
    }

    public static void AddPublicConstructor(CodeWriter cw, string valueObjectTypeName, bool hasDefaultValue)
    {
        if (hasDefaultValue)
        {
            cw.AppendLine($"public {valueObjectTypeName}()");
            using (cw.AddBlock())
            {
                cw.AppendLine("Value = DefaultValue.Value;");
            }
        }
        else
        {
            cw.AppendLine($"[global::System.Obsolete($\"Use {valueObjectTypeName}.{{nameof(From)}} instead.\", error: true)]");
            cw.AppendLine($"public {valueObjectTypeName}()");

            using (cw.AddBlock())
            {
                cw.AppendLine($"throw new global::System.InvalidOperationException($\"Use {valueObjectTypeName}.{{nameof(From)}} instead.\");");
            }
        }
    }

    public static void AddPrivateConstructor(CodeWriter cw, string valueObjectTypeName, string innerValueTypeName)
    {
        cw.AppendLine($"private {valueObjectTypeName}({innerValueTypeName} value)");
        using (cw.AddBlock())
        {
            cw.AppendLine("Value = value;");
        }
    }

    public static void OverrideBaseMethods(CodeWriter cw)
    {
        // hash code
        cw.AppendLine("public override int GetHashCode() => Value.GetHashCode();");
        cw.AppendLine();

        // ToString
        cw.AppendLine("public override string ToString() => Value.ToString();");
        cw.AppendLine();
    }

    public static void ImplementEqualsMethods(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName,
        string innerValueTypeNullableAnnotation,
        bool hasDefaultEqualityComparer)
    {
        // IEquality<Self>
        cw.AppendLine($"public bool Equals({valueObjectTypeName} other) => Equals(other.Value);");

        // IEquality<Value>
        if (hasDefaultEqualityComparer)
        {
            cw.AppendLine($"public bool Equals({innerValueTypeName}{innerValueTypeNullableAnnotation} other) => InnerValueDefaultEqualityComparer.Equals(Value, other);");
        }
        else
        {
            cw.AppendLine($"public bool Equals({innerValueTypeName}{innerValueTypeNullableAnnotation} other) => Value.Equals(other);");
        }

        // with equality comparer
        cw.AppendLine($"public bool Equals({valueObjectTypeName} other, global::System.Collections.Generic.IEqualityComparer<{innerValueTypeName}> comparer) => comparer.Equals(Value, other.Value);");

        // object.Equals
        cw.AppendLine("public override bool Equals(object? obj)");
        using (cw.AddBlock())
        {
            cw.AppendLine("if (obj is null) return false;");
            cw.AppendLine($"if (obj is {valueObjectTypeName} value) return Equals(value);");
            cw.AppendLine($"if (obj is {innerValueTypeName} innerValue) return Equals(innerValue);");
            cw.AppendLine("return false;");
        }
    }

    public static void AddEqualityOperators(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static bool operator ==({valueObjectTypeName} left, {valueObjectTypeName} right) => left.Equals(right);");
        cw.AppendLine($"public static bool operator !=({valueObjectTypeName} left, {valueObjectTypeName} right) => !left.Equals(right);");
        cw.AppendLine();

        cw.AppendLine($"public static bool operator ==({valueObjectTypeName} left, {innerValueTypeName} right) => left.Equals(right);");
        cw.AppendLine($"public static bool operator !=({valueObjectTypeName} left, {innerValueTypeName} right) => !left.Equals(right);");
        cw.AppendLine();

        cw.AppendLine($"public static bool operator ==({innerValueTypeName} left, {valueObjectTypeName} right) => right.Equals(left);");
        cw.AppendLine($"public static bool operator !=({innerValueTypeName} left, {valueObjectTypeName} right) => !right.Equals(left);");
        cw.AppendLine();
    }

    public static void AddExplicitCastOperators(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static explicit operator {valueObjectTypeName}({innerValueTypeName} value) => From(value);");
        cw.AppendLine($"public static explicit operator {innerValueTypeName}({valueObjectTypeName} value) => value.Value;");
        cw.AppendLine();
    }

    public static void AddGuidSpecificCode(
        CodeWriter cw,
        string valueObjectTypeName,
        string innerValueTypeName)
    {
        cw.AppendLine($"public static {valueObjectTypeName} NewId() => From({innerValueTypeName}.NewGuid());");
        cw.AppendLine();
    }

    private readonly struct Target : IEquatable<Target>
    {
        public readonly StructDeclarationSyntax Syntax;
        public readonly AttributeData AttributeData;

        public Target(StructDeclarationSyntax syntax, AttributeData attributeData)
        {
            Syntax = syntax;
            AttributeData = attributeData;
        }

        public bool Equals(Target other)
        {
            return Syntax.Equals(other.Syntax) && AttributeData.Equals(other.AttributeData);
        }

        public override bool Equals(object? obj)
        {
            return obj is Target other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Syntax.GetHashCode() * 397) ^ AttributeData.GetHashCode();
            }
        }
    }
}
