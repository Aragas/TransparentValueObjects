using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TransparentValueObjects;

[Generator]
public class ValueObjectIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TransparentValueObjects.Generated";
    private const string AttributeClassName = "ValueObjectAttribute";

    private const string AugmentedNamespace = "TransparentValueObjects.Augments";
    private const string ValueObjectInterfaceName = "IValueObject";
    private const string HasDefaultValueInterfaceName = "IHasDefaultValue";

    private const string AttributeSourceCode =
        $$"""
          // <auto-generated/>

          namespace {{GeneratedNamespace}}
          {
              [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Auto-generated")]
              [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
              public class {{AttributeClassName}}<T> : global::System.Attribute { }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeClassName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                Predicate,
                Transform
            )
            .Where(static target => target is not null);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, tuple) => Generate(ctx, tuple.Left, tuple.Right)
        );
    }

    private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is StructDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static Target? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var syntaxNode = (StructDeclarationSyntax) context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(syntaxNode, cancellationToken);

        if (symbol is null) return null;

        var attributes = symbol.GetAttributes();
        if (attributes.Length == 0) return null;

        var attributeData = attributes.FirstOrDefault(static a => a?.AttributeClass?.Name == $"{AttributeClassName}");
        if (attributeData is null) return null;

        return new Target(syntaxNode, attributeData);
    }

    private static void Generate(SourceProductionContext context, Compilation compilation, ImmutableArray<Target?> targets)
    {
        foreach (var target in targets)
        {
            if (target is null) continue;
            var syntax = target.Syntax;
            var attributeData = target.AttributeData;

            var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(syntax);

            if (symbol is not INamedTypeSymbol namedTypeSymbol) continue;

            var namespaceName = namedTypeSymbol.ContainingNamespace.ToDisplayString();
            var identifier = namedTypeSymbol.Name;

            var underlyingType = attributeData.AttributeClass?.TypeArguments.FirstOrDefault();
            if (underlyingType is not INamedTypeSymbol underlyingNamedType) continue;

            var typeIdentifier = $"global::{underlyingNamedType.ContainingNamespace.ToDisplayString()}.{underlyingNamedType.Name}";
            var typeNullableAnnotation = underlyingNamedType.IsReferenceType ? "?" : "";

            var existingInterfaces = namedTypeSymbol.Interfaces;

            var cw = new CodeWriter();

            // header, namespace and type definition
            cw.AppendLine("// <auto-generated/>");
            cw.AppendLine($"namespace {namespaceName};");
            cw.AppendLine();

            cw.AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = \"Auto-generated.\")]");
            cw.AppendLine($"readonly partial struct {identifier} :");

            // interfaces
            cw.AppendLine($"\tglobal::{AugmentedNamespace}.{ValueObjectInterfaceName}<{identifier}, {typeIdentifier}>,");
            cw.AppendLine($"\tglobal::System.IEquatable<{identifier}>,");
            cw.AppendLine($"\tglobal::System.IEquatable<{typeIdentifier}>");

            using (cw.AddBlock())
            {
                // backing field
                cw.AppendLine($"public readonly {typeIdentifier} Value;");
                cw.AppendLine();

                // public default constructor
                var hasDefaultValue = existingInterfaces.Any(x => x.Name == HasDefaultValueInterfaceName && x.ContainingNamespace.ToDisplayString() == AugmentedNamespace);

                if (hasDefaultValue)
                {
                    cw.AppendLine($"public {identifier}()");
                    using (cw.AddBlock())
                    {
                        cw.AppendLine("Value = GetDefaultValue().Value;");
                    }
                }
                else
                {
                    cw.AppendLine($"[global::System.Obsolete($\"Use {identifier}.{{nameof(From)}} instead.\", error: true)]");
                    cw.AppendLine($"public {identifier}()");

                    using (cw.AddBlock())
                    {
                        cw.AppendLine($"throw new global::System.InvalidOperationException($\"Use {identifier}.{{nameof(From)}} instead.\");");
                    }
                }

                // private constructor with value
                cw.AppendLine($"private {identifier}({typeIdentifier} value)");
                using (cw.AddBlock())
                {
                    cw.AppendLine("Value = value;");
                }

                // public From method
                cw.AppendLine($"public static {identifier} From({typeIdentifier} value) => new(value);");
                cw.AppendLine();

                // hash code
                cw.AppendLine("public override int GetHashCode() => Value.GetHashCode();");
                cw.AppendLine();

                // ToString
                cw.AppendLine("public override string ToString() => Value.ToString();");
                cw.AppendLine();

                // IEquality<Self>
                cw.AppendLine($"public bool Equals({identifier} other) => Value.Equals(other.Value);");

                // IEquality<Value>
                cw.AppendLine($"public bool Equals({typeIdentifier}{typeNullableAnnotation} other) => Value.Equals(other);");

                // with equality comparer
                cw.AppendLine($"public bool Equals({identifier} other, global::System.Collections.Generic.IEqualityComparer<{typeIdentifier}> comparer) => comparer.Equals(Value, other.Value);");

                // object.Equals
                cw.AppendLine("public override bool Equals(object? obj)");
                using (cw.AddBlock())
                {
                    cw.AppendLine("if (obj is null) return false;");
                    cw.AppendLine($"if (obj is {identifier} value) return Equals(value);");
                    cw.AppendLine($"if (obj is {typeIdentifier} innerValue) return Equals(innerValue);");
                    cw.AppendLine("return false;");
                }

                // equality operators
                cw.AppendLine($"public static bool operator ==({identifier} left, {identifier} right) => left.Equals(right);");
                cw.AppendLine($"public static bool operator !=({identifier} left, {identifier} right) => !left.Equals(right);");
                cw.AppendLine();

                cw.AppendLine($"public static bool operator ==({identifier} left, {typeIdentifier} right) => left.Equals(right);");
                cw.AppendLine($"public static bool operator !=({identifier} left, {typeIdentifier} right) => !left.Equals(right);");
                cw.AppendLine();

                cw.AppendLine($"public static bool operator ==({typeIdentifier} left, {identifier} right) => right.Equals(left);");
                cw.AppendLine($"public static bool operator !=({typeIdentifier} left, {identifier} right) => !right.Equals(left);");
                cw.AppendLine();

                // explicit cast operators
                cw.AppendLine($"public static explicit operator {identifier}({typeIdentifier} value) => From(value);");
                cw.AppendLine($"public static explicit operator {typeIdentifier}({identifier} value) => value.Value;");
                cw.AppendLine();
            }

            context.AddSource($"{identifier}.g.cs", SourceText.From(cw.ToString(), Encoding.UTF8));
        }
    }

    private class Target
    {
        public readonly StructDeclarationSyntax Syntax;
        public readonly AttributeData AttributeData;

        public Target(StructDeclarationSyntax syntax, AttributeData attributeData)
        {
            Syntax = syntax;
            AttributeData = attributeData;
        }
    }
}
